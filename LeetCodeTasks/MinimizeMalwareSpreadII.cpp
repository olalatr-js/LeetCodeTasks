#include <vector>
#include <unordered_map>
#include <stack>

namespace
{
class Solution 
{
public:
    int minMalwareSpread(std::vector<std::vector<int>>& graph, std::vector<int>& initial)
    {
        m_N = static_cast<int>(initial.size());
        std::unordered_map<int, int> node2can_reach(m_N);
        for (auto i : initial)
        {
            const auto number_can_reach = dfs_count(graph, i);
            node2can_reach.insert({i, number_can_reach});
        }

        auto itr = node2can_reach.cbegin();
        auto node_to_remove = itr->first;
        auto can_reach_num = itr->second;
        // find max by value of node2can_reach
        for (; itr != node2can_reach.cend(); ++itr)
        {
            if (itr->second > can_reach_num)
            {
                node_to_remove = itr->first;
                can_reach_num = itr->second;
                continue;
            }

            if (itr->second == can_reach_num && itr->first < node_to_remove)
            {
                node_to_remove = itr->first;
            }
        }

        return node_to_remove;
    }

private:
    int dfs_count(const std::vector<std::vector<int>>& graph, int node)
    {
        std::vector<bool> visited(m_N, false);
        auto cnt = 0;
        std::stack<int> stk;
        stk.push(node);
        visited[node] = true;
        ++cnt;
        while (!stk.empty())
        {
            const auto curr = stk.top();
            stk.pop();
            const auto& edges = graph[curr];
            for (auto to = 0; to < m_N; ++to)
            {
                if (edges[to] && !visited[to])
                {
                    stk.push(to);
                    visited[to] = true;
                    ++cnt;
                }
            }
        }

        return cnt;
    }

    int m_N;
};
}

void MinimizeMalwareSpreadII()
{

}